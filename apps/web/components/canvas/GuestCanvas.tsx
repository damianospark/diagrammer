"use client"

import { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useRef, useState } from "react"
import { TransformComponent, TransformWrapper, ReactZoomPanPinchRef } from "react-zoom-pan-pinch"
import * as htmlToImage from "html-to-image"
import { DiagramRenderer, MERMAID_THEME_OPTIONS, MermaidThemeOption } from "@/components/diagram-renderer"
import { Button } from "@/components/ui/button"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { AlertCircle, Loader2, RefreshCcw, ZoomIn, ZoomOut } from "lucide-react"
import { cn } from "@/lib/utils"

export type GuestCanvasHandle = {
  toPNG: () => Promise<string | null>
  toBlob: () => Promise<Blob | null>
  getSVG: () => string | null
  resetView: () => void
  refresh: () => Promise<void>
}

type GuestCanvasProps = {
  code: string
  engine: "mermaid" | "visjs"
  title?: string
  onRendered?: (status: 'ok' | 'error', message?: string) => void
}

const TRANSPARENT_PIXEL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAukB9pR6itkAAAAASUVORK5CYII="

export const GuestCanvas = forwardRef<GuestCanvasHandle, GuestCanvasProps>(function GuestCanvas(
  { code, engine, onRendered },
  ref
) {
  const transformRef = useRef<ReactZoomPanPinchRef | null>(null)
  const visibleRef = useRef<HTMLDivElement>(null)
  const [rendering, setRendering] = useState(false)
  const [renderError, setRenderError] = useState<string | null>(null)
  const [captureError, setCaptureError] = useState<string | null>(null)
  const latestBlobRef = useRef<Blob | null>(null)
  const latestSVGRef = useRef<string | null>(null)
  const latestObjectUrlRef = useRef<string | null>(null)
  const [mermaidTheme, setMermaidTheme] = useState<MermaidThemeOption>('default')

  useEffect(() => {
    // ÏΩîÎìúÍ∞Ä Î≥ÄÍ≤ΩÎêòÎ©¥ Î†åÎçîÎßÅ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    if (code) {
      console.log('üîÑ GuestCanvas: New code detected, setting rendering=true')
      setRendering(true)
    } else {
      setRendering(false)
    }

    setRenderError(null)
    setCaptureError(null)
    latestBlobRef.current = null
    latestSVGRef.current = null

    if (latestObjectUrlRef.current) {
      URL.revokeObjectURL(latestObjectUrlRef.current)
      latestObjectUrlRef.current = null
    }

    // Î†åÎçîÎßÅ ÏÉÅÌÉúÍ∞Ä ÏòÅÏõêÌûà Í±∞ÏßìÏùº Í≤ΩÏö∞Î•º ÎåÄÎπÑÌïú ÏïàÏ†ÑÏû•Ïπò
    const safetyTimer = setTimeout(() => {
      setRendering(false)
    }, 5000) // 5Ï¥à ÌõÑÏóê Í∞ïÏ†úÎ°ú Î†åÎçîÎßÅ ÏÉÅÌÉú Ìï¥Ï†ú

    return () => clearTimeout(safetyTimer)
  }, [code, engine])

  const backgroundColor = useMemo(() => {
    if (typeof window === "undefined") return "#ffffff"
    const root = getComputedStyle(document.documentElement)
    return root.getPropertyValue("--color-background").trim() || "#ffffff"
  }, [])

  // ÎåÄÏ≤¥ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ìï®Ïàò
  const createFallbackImage = useCallback(async (originalImage: HTMLImageElement): Promise<{image: HTMLImageElement, isFallback: boolean}> => {
    try {
      const canvas = document.createElement("canvas")
      canvas.width = originalImage.naturalWidth || originalImage.width
      canvas.height = originalImage.naturalHeight || originalImage.height
      const ctx = canvas.getContext("2d")
      
      if (!ctx) throw new Error("Canvas Ïª®ÌÖçÏä§Ìä∏Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§")
      
      // Ìà¨Î™ÖÌïú Î∞∞Í≤Ω ÏÇ¨Ïö© (Î∞∞Í≤Ω Ï±ÑÏö∞Í∏∞ Ï†úÍ±∞)
      // ctx.fillStyle = "white"
      // ctx.fillRect(0, 0, canvas.width, canvas.height)
      
      // Ïù¥ÎØ∏ÏßÄ Í∑∏Î¶¨Í∏∞
      ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height)
      
      // ÏÉà Ïù¥ÎØ∏ÏßÄ Í∞ùÏ≤¥ ÏÉùÏÑ±
      return new Promise((resolve, reject) => {
        const newImage = new Image()
        newImage.onload = () => resolve({image: newImage, isFallback: true})
        newImage.onerror = () => reject(new Error("ÎåÄÏ≤¥ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ïã§Ìå®"))
        newImage.src = canvas.toDataURL("image/png")
      })
    } catch (e) {
      console.error("ÎåÄÏ≤¥ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ï§ë Ïò§Î•ò:", e)
      throw new Error("Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§")
    }
  }, [])

  // SVGÎ•º PNGÎ°ú Î≥ÄÌôòÌïòÎäî Ìï®Ïàò - Ïô∏Î∂Ä Î¶¨ÏÜåÏä§ Ïù∏ÎùºÏù∏Ìôî Î∞è Ï∫îÎ≤ÑÏä§ Ïò§Ïóº Î∞©ÏßÄ Î°úÏßÅ Ìè¨Ìï®
  const svgToPngBlob = useCallback(async (svgEl: SVGSVGElement) => {
    const clone = svgEl.cloneNode(true) as SVGSVGElement
    clone.setAttribute("xmlns", "http://www.w3.org/2000/svg")

    const inlineExternalResources = async (root: SVGSVGElement) => {
      const XLINK_NS = "http://www.w3.org/1999/xlink"

      const stats = {
        inlined: 0,
        removed: 0,
        failed: 0,
        styleUpdated: 0,
        stripped: 0,
      }

      const blobToDataURL = (blob: Blob) =>
        new Promise<string>((resolve, reject) => {
          const reader = new FileReader()
          reader.onload = () => resolve(String(reader.result))
          reader.onerror = () => reject(new Error("Î¶¨ÏÜåÏä§ Ïù∏ÎùºÏù∏ Ï≤òÎ¶¨ Ïã§Ìå®"))
          reader.readAsDataURL(blob)
        })

      const toAbsoluteUrl = (rawUrl: string) => {
        try {
          return new URL(rawUrl, window.location.href).href
        } catch (e) {
          console.warn("‚ö†Ô∏è URL Ìï¥ÏÑù Ïã§Ìå®", rawUrl, e)
          stats.failed += 1
          return null
        }
      }

      const convertUrl = async (rawUrl: string) => {
        if (!rawUrl) return null
        const trimmed = rawUrl.trim()
        if (trimmed.startsWith("#") || trimmed.startsWith("data:")) return trimmed
        if (trimmed.startsWith("blob:")) return trimmed

        const absolute = toAbsoluteUrl(trimmed)
        if (!absolute) return null

        try {
          const response = await fetch(absolute, {
            mode: absolute.startsWith(window.location.origin) ? "same-origin" : "cors",
            credentials: absolute.startsWith(window.location.origin) ? "include" : "omit",
          })
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`)
          }
          const blob = await response.blob()
          stats.inlined += 1
          return await blobToDataURL(blob)
        } catch (error) {
          console.warn("‚ö†Ô∏è Ïô∏Î∂Ä Î¶¨ÏÜåÏä§ Ïù∏ÎùºÏù∏ Ïã§Ìå®", { url: absolute, error })
          stats.failed += 1
          return null
        }
      }

      const processSvgImage = async (imageEl: SVGImageElement) => {
        const hrefAttr =
          imageEl.getAttribute("href") ||
          imageEl.getAttributeNS(XLINK_NS, "href") ||
          imageEl.getAttribute("xlink:href")

        if (!hrefAttr || hrefAttr.startsWith("data:")) return

        const dataUrl = await convertUrl(hrefAttr)
        if (dataUrl) {
          imageEl.removeAttribute("href")
          imageEl.removeAttribute("xlink:href")
          imageEl.setAttribute("href", dataUrl)
          imageEl.setAttributeNS(XLINK_NS, "href", dataUrl)
        } else {
          imageEl.remove()
          stats.removed += 1
        }
      }

      const processHtmlImage = async (imageEl: HTMLImageElement) => {
        const srcAttr = imageEl.getAttribute("src")
        if (!srcAttr || srcAttr.startsWith("data:")) return

        const dataUrl = await convertUrl(srcAttr)
        if (dataUrl) {
          imageEl.removeAttribute("srcset")
          imageEl.setAttribute("src", dataUrl)
        } else {
          imageEl.setAttribute("src", TRANSPARENT_PIXEL)
          imageEl.removeAttribute("srcset")
          stats.removed += 1
        }
      }

      const processInlineStyles = async (el: Element) => {
        const styleValue = el.getAttribute("style")
        if (!styleValue || !styleValue.includes("url(")) return

        const urlRegex = /url\(([^)]+)\)/gi
        let match: RegExpExecArray | null
        let updatedStyle = styleValue
        let replaced = false

        while ((match = urlRegex.exec(styleValue)) !== null) {
          const raw = match[1]?.trim().replace(/^['"]|['"]$/g, "") || ""
          if (!raw || raw.startsWith("#") || raw.startsWith("data:")) continue

          const dataUrl = await convertUrl(raw)
          if (dataUrl) {
            updatedStyle = updatedStyle.replace(match[0], `url("${dataUrl}")`)
            replaced = true
          } else {
            updatedStyle = updatedStyle.replace(match[0], "none")
            stats.removed += 1
            replaced = true
          }
        }

        if (replaced) {
          el.setAttribute("style", updatedStyle)
          stats.styleUpdated += 1
        }
      }

      const processStyleTag = async (styleEl: SVGStyleElement) => {
        const cssText = styleEl.textContent || ""
        if (!cssText.includes("url(")) return

        const urlRegex = /url\(([^)]+)\)/gi
        let match: RegExpExecArray | null
        let updatedCss = cssText
        let replaced = false

        while ((match = urlRegex.exec(cssText)) !== null) {
          const raw = match[1]?.trim().replace(/^['"]|['"]$/g, "") || ""
          if (!raw || raw.startsWith("#") || raw.startsWith("data:")) continue

          const dataUrl = await convertUrl(raw)
          if (dataUrl) {
            updatedCss = updatedCss.replace(match[0], `url("${dataUrl}")`)
            replaced = true
          } else {
            updatedCss = updatedCss.replace(match[0], "none")
            replaced = true
            stats.removed += 1
          }
        }

        if (replaced) {
          styleEl.textContent = updatedCss
          stats.styleUpdated += 1
        }
      }

      const sanitizeResidualAttributes = () => {
        const urlPattern = /https?:\/\//i
        const ignoreAttrPrefixes = ["xmlns", "xml:"]

        root.querySelectorAll<SVGElement | HTMLElement>("*").forEach((el) => {
          const attributeNames = el.getAttributeNames()
          attributeNames.forEach((attrName) => {
            if (ignoreAttrPrefixes.some((prefix) => attrName.startsWith(prefix))) {
              return
            }

            const value = el.getAttribute(attrName)
            if (!value) return

            if (attrName === "style") {
              if (!value.includes("url(")) return
              if (urlPattern.test(value)) {
                el.removeAttribute(attrName)
                stats.stripped += 1
              }
              return
            }

            if (urlPattern.test(value)) {
              el.removeAttribute(attrName)
              stats.stripped += 1
            }
          })
        })
      }

      const svgImages = Array.from(root.querySelectorAll<SVGImageElement>("image"))
      const htmlImages = Array.from(root.querySelectorAll<HTMLImageElement>("img"))
      const styledElements = Array.from(root.querySelectorAll<HTMLElement | SVGElement>("*[style*='url(']"))
      const styleTags = Array.from(root.querySelectorAll<SVGStyleElement>("style"))
      const stylesheetLinks = Array.from(root.querySelectorAll<HTMLLinkElement>("link[rel='stylesheet']"))

      for (const imageEl of svgImages) {
        await processSvgImage(imageEl)
      }

      for (const imageEl of htmlImages) {
        await processHtmlImage(imageEl)
      }

      for (const elem of styledElements) {
        await processInlineStyles(elem)
      }

      for (const styleEl of styleTags) {
        await processStyleTag(styleEl)
      }

      if (stylesheetLinks.length) {
        stylesheetLinks.forEach((link) => {
          link.remove()
          stats.stripped += 1
        })
      }

      sanitizeResidualAttributes()

      return stats
    }

    const bbox = (() => {
      try {
        return svgEl.getBBox()
      } catch {
        return null
      }
    })()

    const fallbackViewBox = svgEl.viewBox?.baseVal
    const fallbackWidth = Number(svgEl.getAttribute("width")) || fallbackViewBox?.width || svgEl.clientWidth || 1
    const fallbackHeight = Number(svgEl.getAttribute("height")) || fallbackViewBox?.height || svgEl.clientHeight || 1

    if (bbox && bbox.width > 0 && bbox.height > 0) {
      clone.setAttribute("viewBox", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`)
      clone.setAttribute("width", `${bbox.width}`)
      clone.setAttribute("height", `${bbox.height}`)
    } else {
      if (!clone.getAttribute("viewBox")) {
        clone.setAttribute("viewBox", `0 0 ${fallbackWidth} ${fallbackHeight}`)
      }
      clone.setAttribute("width", `${fallbackWidth}`)
      clone.setAttribute("height", `${fallbackHeight}`)
    }

    const inlineStats = await inlineExternalResources(clone)
    if (inlineStats.inlined || inlineStats.removed || inlineStats.failed || inlineStats.styleUpdated || inlineStats.stripped) {
      console.debug("üß© SVG Î¶¨ÏÜåÏä§ Ïù∏ÎùºÏù∏ Ï≤òÎ¶¨ Í≤∞Í≥º", inlineStats)
    }

    const serializer = new XMLSerializer()
    const hasExternalReference = (input: string) => {
      const externalPattern = /(href|xlink:href|src|style|url\()\s*=?[^>]*https?:\/\//i
      return externalPattern.test(input)
    }

    let svgString = serializer.serializeToString(clone)
    if (hasExternalReference(svgString)) {
      console.warn("‚ö†Ô∏è SVG ÎÇ¥ Ïô∏Î∂Ä URL ÏûîÏ°¥: Î≥¥Ï†ï ÏãúÎèÑ")
      await inlineExternalResources(clone)
      svgString = serializer.serializeToString(clone)
    }
    const svgBlob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" })
    const url = URL.createObjectURL(svgBlob)

    try {
      // SVGÎ•º Îç∞Ïù¥ÌÑ∞ URLÎ°ú Î≥ÄÌôòÌïòÏó¨ Ïù¥ÎØ∏ÏßÄÎ°ú Î°úÎìú
      // Ïù¥ Î∞©ÏãùÏùÄ Î°úÏª¨ ÏõêÎ≥∏ÏùÑ ÏÇ¨Ïö©ÌïòÎØÄÎ°ú cross-origin Ï†úÌïúÏùÑ ÌîºÌï† Ïàò ÏûàÏùå
      const dataUrl = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgString)}`;
      
      const img = await new Promise<HTMLImageElement>((resolve, reject) => {
        const image = new Image()
        image.decoding = "async"
        // Îç∞Ïù¥ÌÑ∞ URLÏùÑ ÏÇ¨Ïö©ÌïòÎØÄÎ°ú crossOrigin ÏÜçÏÑ±Ïù¥ ÌïÑÏöîÏóÜÏùå
        image.onload = () => resolve(image)
        image.onerror = (error) => {
          console.error("Ïù¥ÎØ∏ÏßÄ Î°úÎìú Ïò§Î•ò:", error)
          reject(new Error("Ïù¥ÎØ∏ÏßÄ Î°úÎìú Ïò§Î•ò"))
        }
        image.src = dataUrl
      })

      const pixelRatio = window.devicePixelRatio > 1 ? 2 : 1
      const width = clone.width.baseVal?.value || fallbackWidth
      const height = clone.height.baseVal?.value || fallbackHeight
      const canvas = document.createElement("canvas")
      canvas.width = Math.max(1, Math.round(width * pixelRatio))
      canvas.height = Math.max(1, Math.round(height * pixelRatio))

      const ctx = canvas.getContext("2d")
      if (!ctx) throw new Error("Canvas Ïª®ÌÖçÏä§Ìä∏ ÏÉùÏÑ± Ïã§Ìå®")

      // Î∞∞Í≤ΩÏùÑ Ìà¨Î™ÖÌïòÍ≤å ÏÑ§Ï†ï (Î∞∞Í≤Ω Ï±ÑÏö∞Í∏∞ Ï†úÍ±∞)
      // Ìà¨Î™ÖÌïú Î∞∞Í≤ΩÏùÑ ÏúÑÌï¥ fillRect ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå
      
      // Îç∞Ïù¥ÌÑ∞ URLÏùÑ ÏÇ¨Ïö©ÌïòÎØÄÎ°ú Ï∫îÎ≤ÑÏä§ Ïò§Ïóº Í≤ÄÏÇ¨ ÏóÜÏù¥ Î∞îÎ°ú Í∑∏Î¶¨Í∏∞ Í∞ÄÎä•
      try {
        // Ïù¥ÎØ∏ÏßÄ Í∑∏Î¶¨Í∏∞
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      } catch (drawError) {
        console.error("Ïù¥ÎØ∏ÏßÄ Í∑∏Î¶¨Í∏∞ Ïò§Î•ò:", drawError);
        // Ïù¥ÎØ∏ÏßÄ Í∑∏Î¶¨Í∏∞ Ïã§Ìå® Ïãú Î∞∞Í≤ΩÎßå ÏûàÎäî Ï∫îÎ≤ÑÏä§Ïóê Ïò§Î•ò Î©îÏãúÏßÄ ÌëúÏãú
        ctx.font = "14px sans-serif";
        ctx.fillStyle = "#666";
        ctx.fillText("[Ïù¥ÎØ∏ÏßÄ Î°úÎìú Ïò§Î•ò]", 20, canvas.height / 2);
      }

      // Îç∞Ïù¥ÌÑ∞ URLÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Ïù¥ÎØ∏ÏßÄÎ•º Í∑∏Î†∏ÏúºÎØÄÎ°ú Ï∫îÎ≤ÑÏä§Îäî Ïò§ÏóºÎêòÏßÄ ÏïäÏùå
      // ÏßÅÏ†ë BlobÏúºÎ°ú Î≥ÄÌôò Í∞ÄÎä•
      const blob = await new Promise<Blob>((resolve, reject) => {
        try {
          // Ìà¨Î™ÖÎèÑÎ•º ÏßÄÏõêÌïòÎäî PNG ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
          canvas.toBlob((b) => {
            if (b) resolve(b);
            else reject(new Error("PNG Î≥ÄÌôò Ïã§Ìå®"));
          }, "image/png", 1.0); // ÌíàÏßàÏùÑ 1.0ÏúºÎ°ú ÏÑ§Ï†ïÌïòÏó¨ Ìà¨Î™ÖÎèÑ Ïú†ÏßÄ
        } catch (e) {
          console.error("Blob Î≥ÄÌôò Ïò§Î•ò:", e);
          reject(new Error("Ïù¥ÎØ∏ÏßÄ Î≥ÄÌôò Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§"));
        }
      })

      return { blob, svgString }
    } finally {
      URL.revokeObjectURL(url)
    }
  }, [backgroundColor])

  // Îã§Ïù¥Ïñ¥Í∑∏Îû® Ï∫°Ï≤ò Ìï®Ïàò - SVG ÎòêÎäî HTML ÏöîÏÜåÎ•º PNGÎ°ú Î≥ÄÌôò
  const captureDiagram = useCallback(async () => {
    if (!visibleRef.current) return null
    try {
      const svgEl = visibleRef.current.querySelector("svg") as SVGSVGElement | null
      if (svgEl) {
        const { blob, svgString } = await svgToPngBlob(svgEl)
        latestBlobRef.current = blob
        latestSVGRef.current = svgString
        setCaptureError(null)
        return blob
      }

      // html-to-imageÏùò cacheBust ÏòµÏÖòÏùÑ trueÎ°ú ÎëêÎ©¥ ÎÇ¥Î∂Ä Ïù¥ÎØ∏ÏßÄÏùò srcÏóê ?_t=‚Ä¶Î•º ÎçßÎ∂ôÏûÖÎãàÎã§.
      // blob: URLÏóêÎèÑ ÏøºÎ¶¨Ïä§Ìä∏ÎßÅÏù¥ Î∂ôÏúºÎ©¥ Î∏åÎùºÏö∞Ï†ÄÍ∞Ä blobÏùÑ Ï∞æÏßÄ Î™ªÌï¥ ERR_FILE_NOT_FOUNDÍ∞Ä Î∞úÏÉùÌï† Ïàò ÏûàÏñ¥ falseÎ°ú Îë°ÎãàÎã§.
      // html-to-image Ìò∏Ï∂ú Ï†Ñ Ïô∏Î∂Ä Î¶¨ÏÜåÏä§ Ï∞∏Ï°∞ Ï†úÍ±∞ ÏãúÎèÑ
      const container = visibleRef.current;
      const images = Array.from(container.querySelectorAll('img'));
      
      // Î™®Îì† Ïù¥ÎØ∏ÏßÄÏóê crossOrigin ÏÜçÏÑ± Ï∂îÍ∞Ä Î∞è Ïô∏Î∂Ä URL Ï≤òÎ¶¨
      for (const img of images) {
        if (!img.getAttribute('crossorigin')) {
          img.setAttribute('crossorigin', 'anonymous');
        }
        
        const src = img.getAttribute('src');
        if (src && !src.startsWith('data:') && !src.startsWith('blob:')) {
          // Ïô∏Î∂Ä URLÏùÑ Ìà¨Î™Ö ÌîΩÏÖÄÎ°ú ÎåÄÏ≤¥
          img.setAttribute('data-original-src', src);
          img.setAttribute('src', TRANSPARENT_PIXEL);
        }
      }
      
      const blob = await htmlToImage.toBlob(
        visibleRef.current,
        {
          pixelRatio: window.devicePixelRatio > 1 ? 2 : 1,
          backgroundColor: 'transparent', // Î∞∞Í≤ΩÏùÑ Ìà¨Î™ÖÌïòÍ≤å ÏÑ§Ï†ï
          cacheBust: false,
          imagePlaceholder: TRANSPARENT_PIXEL,
          skipAutoScale: true,
          canvasWidth: container.clientWidth * 2,
          canvasHeight: container.clientHeight * 2,
        } as Parameters<typeof htmlToImage.toBlob>[1]
      )
      
      // ÏõêÎûò Ïù¥ÎØ∏ÏßÄ ÏÜåÏä§ Î≥µÏõê
      for (const img of images) {
        const originalSrc = img.getAttribute('data-original-src');
        if (originalSrc) {
          img.setAttribute('src', originalSrc);
          img.removeAttribute('data-original-src');
        }
      }
      if (!blob) throw new Error("Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§")
      latestBlobRef.current = blob
      latestSVGRef.current = null
      setCaptureError(null)
      return blob
    } catch (err: any) {
      const msg = err?.message || "Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§"
      setCaptureError(msg)
      throw err
    }
  }, [backgroundColor, svgToPngBlob])

  const ensureSnapshot = useCallback(
    async (force: boolean = false) => {
      if (!visibleRef.current) return null
      if (force || !latestBlobRef.current) {
        await captureDiagram()
      }
      return latestBlobRef.current
    },
    [captureDiagram]
  )

  useEffect(() => {
    return () => {
      if (latestObjectUrlRef.current) {
        URL.revokeObjectURL(latestObjectUrlRef.current)
        latestObjectUrlRef.current = null
      }
    }
  }, [])

  useImperativeHandle(
    ref,
    () => ({
      async toPNG() {
        const blob = await ensureSnapshot()
        if (!blob) return null
        if (latestObjectUrlRef.current) {
          URL.revokeObjectURL(latestObjectUrlRef.current)
        }
        const url = URL.createObjectURL(blob)
        latestObjectUrlRef.current = url
        return url
      },
      async toBlob() {
        const blob = await ensureSnapshot()
        return blob ?? null
      },
      getSVG() {
        if (!latestSVGRef.current && visibleRef.current) {
          latestSVGRef.current = visibleRef.current.querySelector("svg")?.outerHTML || null
        }
        return latestSVGRef.current
      },
      resetView() {
        transformRef.current?.resetTransform?.()
      },
      async refresh(force: boolean = true) {
        if (force && latestObjectUrlRef.current) {
          URL.revokeObjectURL(latestObjectUrlRef.current)
          latestObjectUrlRef.current = null
        }
        await ensureSnapshot(force)
      },
    }),
    [ensureSnapshot]
  )

  // Î†åÎçîÎßÅ ÏóîÏßÑ ÌÉÄÏûÖ Ï†ÄÏû•
  const [renderedEngineType, setRenderedEngineType] = useState<'mermaid' | 'visjs' | null>(null)

  // Îã§Ïù¥Ïñ¥Í∑∏Îû® Î†åÎçîÎßÅ ÏôÑÎ£å Ìï∏Îì§Îü¨ - Ï∫°Ï≤ò ÌîÑÎ°úÏÑ∏Ïä§ ÏãúÏûë
  const handleRendered = useCallback((status: 'ok' | 'error', message?: string, engineType?: 'mermaid' | 'visjs') => {
    console.log(`üí¨ GuestCanvas: handleRendered called with status=${status}, engineType=${engineType || 'unknown'}`)
    
    // Î†åÎçîÎßÅ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ - Ï¶âÏãú Ï†ÅÏö©
    setRendering(false)
    
    // ÏóîÏßÑ ÌÉÄÏûÖ Ï†ÄÏû•
    if (engineType) {
      setRenderedEngineType(engineType)
    }
    
    // Î∂ÄÎ™®ÏóêÍ≤å ÏÉÅÌÉú Ï†ÑÎã¨
    onRendered?.(status, message)
    
    if (status === 'error') {
      setRenderError(message || 'Îã§Ïù¥Ïñ¥Í∑∏Îû® Î†åÎçîÎßÅ Ïã§Ìå®')
      setCaptureError(null)
    } else {
      setRenderError(null)
      
      // mermaid ÏóîÏßÑÏùº Í≤ΩÏö∞ÏóêÎßå Ï∫°Ï≤ò ÏãúÎèÑ (vis.jsÎäî ÏûêÏ≤¥ Ï°∞Ïûë Í∏∞Îä• ÏÇ¨Ïö©)
      if (engineType !== 'visjs') {
        // Î†åÎçîÎßÅ ÏÑ±Í≥µ Ïãú ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ ÌõÑ Ï∫°Ï≤ò ÏãúÎèÑ (SVGÍ∞Ä ÏôÑÏ†ÑÌûà Î°úÎìúÎêòÎèÑÎ°ù)
        setTimeout(() => {
          captureDiagram().catch((captureErr) => {
            console.warn("Ï∫°Ï≤ò ÌîÑÎ°úÏÑ∏Ïä§ Ïò§Î•ò (Î¨¥ÏãúÎê®):", captureErr)
            /* capture error already surfaced */
          })
        }, 100)
      }
    }
  }, [captureDiagram, onRendered])

  return (
    <div className="relative flex h-full w-full flex-col">
      {/* vis.jsÏùº Í≤ΩÏö∞ TransformWrapperÎ•º ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÍ≥† Îã§Ïù¥Ïñ¥Í∑∏Îû®Îßå Î†åÎçîÎßÅ */}
      {renderedEngineType === 'visjs' ? (
        <div className="w-full h-full">
          <div className="absolute right-4 top-4 z-10 flex items-center gap-2 rounded-md border bg-background/95 p-2 shadow">
            <Select value={mermaidTheme} onValueChange={(value) => setMermaidTheme(value as MermaidThemeOption)} disabled>
              <SelectTrigger className="h-9 w-36">
                <SelectValue placeholder="ÌÖåÎßà" />
              </SelectTrigger>
              <SelectContent>
                {MERMAID_THEME_OPTIONS.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    {option.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <div className="text-xs text-muted-foreground px-2 py-1">
              vis.js ÎÇ¥Ïû• Ï°∞Ïûë Í∏∞Îä• ÏÇ¨Ïö©
            </div>
          </div>
          <div className="w-full h-full">
            <div ref={visibleRef} className="w-full h-full">
              <DiagramRenderer code={code} engine={engine} mermaidTheme={mermaidTheme} onRendered={handleRendered} className="bg-transparent" />
            </div>
          </div>
          {rendering && !renderError && (
            <div className="absolute inset-0 flex items-center justify-center rounded-lg bg-background/70">
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <Loader2 className="h-4 w-4 animate-spin" /> Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏùÑ Î≥ÄÌôò Ï§ëÏûÖÎãàÎã§‚Ä¶
              </div>
            </div>
          )}
          {renderError && (
            <div className="absolute inset-0 flex items-center justify-center rounded-lg bg-background/80">
              <div className="flex items-center gap-2 text-sm text-destructive">
                <AlertCircle className="h-4 w-4" /> {renderError}
              </div>
            </div>
          )}
        </div>
      ) : (
        <TransformWrapper
          ref={transformRef}
          minScale={0.4}
          maxScale={4}
          initialScale={1}
          wheel={{ step: 0.2, smoothStep: 0.01 }}
          doubleClick={{ disabled: true }}
          limitToBounds={false}
          centerZoomedOut={false}
          alignmentAnimation={{ disabled: true }}
          panning={{ velocityDisabled: true }}
        >
        {({ zoomIn, zoomOut, resetTransform }) => (
          <>
            <div className="absolute right-4 top-4 z-10 flex items-center gap-2 rounded-md border bg-background/95 p-2 shadow">
              <Select
                value={mermaidTheme}
                onValueChange={(value) => setMermaidTheme(value as MermaidThemeOption)}
                disabled={engine !== 'mermaid'}
              >
                <SelectTrigger className="h-9 w-36">
                  <SelectValue placeholder="ÌÖåÎßà" />
                </SelectTrigger>
                <SelectContent>
                  {MERMAID_THEME_OPTIONS.map((option) => (
                    <SelectItem key={option.value} value={option.value}>
                      {option.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <div className="flex items-center gap-1">
                <Button size="icon" variant="outline" onClick={() => zoomOut()} title="Ï∂ïÏÜå" aria-label="Ï∂ïÏÜå">
                  <ZoomOut className="h-4 w-4" />
                </Button>
                <Button size="icon" variant="outline" onClick={() => zoomIn()} title="ÌôïÎåÄ" aria-label="ÌôïÎåÄ">
                  <ZoomIn className="h-4 w-4" />
                </Button>
                <Button size="icon" variant="outline" onClick={() => resetTransform()} title="Î¶¨ÏÖã" aria-label="Î¶¨ÏÖã">
                  <RefreshCcw className="h-4 w-4" />
                </Button>
              </div>
            </div>
            <TransformComponent
              wrapperStyle={{ width: "100%", height: "100%", display: "flex", justifyContent: "center", alignItems: "center" }}
              contentStyle={{ display: "flex", justifyContent: "center", alignItems: "center" }}
            >
              <div
                className={cn(
                  "relative flex min-h-[480px] min-w-[480px] items-center justify-center"
                )}
                style={{ 
                  minHeight: "480px", 
                  minWidth: "480px", 
                  background: "transparent",
                  border: "none"
                }}
              >
                <div ref={visibleRef} className="max-h-[80vh] max-w-[80vw]">
                  <DiagramRenderer 
                    code={code} 
                    engine={engine} 
                    mermaidTheme={mermaidTheme}
                    onRendered={handleRendered} 
                    className="bg-transparent" 
                  />
                </div>
                {rendering && !renderError && (
                  <div className="absolute inset-0 flex items-center justify-center rounded-lg bg-background/70">
                    <div className="flex items-center gap-2 text-sm text-muted-foreground">
                      <Loader2 className="h-4 w-4 animate-spin" /> Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏùÑ Î≥ÄÌôò Ï§ëÏûÖÎãàÎã§‚Ä¶
                    </div>
                  </div>
                )}
                {renderError && (
                  <div className="absolute inset-0 flex items-center justify-center rounded-lg bg-background/80">
                    <div className="flex items-center gap-2 text-sm text-destructive">
                      <AlertCircle className="h-4 w-4" /> {renderError}
                    </div>
                  </div>
                )}
              </div>
            </TransformComponent>
          </>
        )}
      </TransformWrapper>
      )}

      {captureError && !renderError && renderedEngineType !== 'visjs' && (
        <div className="absolute bottom-4 right-4 flex items-center gap-2 rounded-md border border-destructive/60 bg-background px-3 py-2 text-xs text-destructive shadow">
          <AlertCircle className="h-3.5 w-3.5" /> {captureError}
        </div>
      )}
    </div>
  )
})

export default GuestCanvas
